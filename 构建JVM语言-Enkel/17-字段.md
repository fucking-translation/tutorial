# 构建JVM语言 - Enkel

<h2 align="center">【第十八节】：字段</h2>

</br>

[原文](http://jakubdziworski.github.io/enkel/2016/05/13/enkel_18_fields.html)

</br>

## 源码

这个项目的源码可以从[Github仓库](https://github.com/JakubDziworski/Enkel-JVM-language)中进行克隆。

## 语法

语法是Java的简化版。你可以指定一个类型和字段的名称，这里没有修饰符和像‘static’，‘volatile’，‘transient’等的关键字。我至今仍试图让其保持简单。

```groovy
Fields {
    int field
    start {
        field = 5
        print field
    }
}
```

## 语法变更

直到现在，你只能在类的主体内定义方法，是时候引入字段了：

```antlr
classBody :  field* function* ;
field : type name;
```

我还为已定义的变量添加了赋值语句：

```antlr
assignment : name EQUALS expression;
```

### 为什么我这么久都没有实现赋值语句？

要使用字段，你必须将它们分配给某些对象。事实证明，我尚未实现诸如已声明变量的赋值语句之类的基本功能。我为什么不这么做呢？好吧，我是有意为之。

其背后的原因是我希望变量是不可变的。分配意味着改变状态 - 改变状态会导致很多问题（同步，副作用，内存泄漏等）。

你是否曾阅读过像这样的Java代码：

```java
Stuff trustMeIWontModifyYourArg(SomeObject arg) {
    // ... 999 lines of code 
    arg = null; //or some other nasty hidden stuff
    // ...another 999 lines of code
}
```

通过阅读签名，你可能会想：“嗯...这种方法会修改参数吗？哦，它没有final修饰符，但是我们大多数Java开发者都忽略了它。从它的名称看，它不应该修改我的参数，所以我们就使用它。”

两小时之后，在你的代码中可能会随机的抛出空指针异常。这个方法修改了你的参数。

如果你的方法没有副作用，则可以轻松的使用它们并行化，而不用担心同步问题和其他讨厌的东西。这样的方法没有状态 = 没有副作用！实现副作用的最简单的方式就是仅使用值（常量）。

你可以在Bob叔叔的精彩演讲（https://youtu.be/7Zlp9rKHGD4?t=11m15s）中了解到更多有关声明的内容以及错误之处，并一探究竟。

## 生成字节码

### 字段声明

声明字段你需要使用asm库中的visitField方法，它将字段添加到[类结构](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1)中的`fields[]`成员中，并自动增加`fields_count`的计数器。

```java
public class FieldGenerator {

    private final ClassWriter classWriter;

    public FieldGenerator(ClassWriter classWriter) {
        this.classWriter = classWriter;
    }

    public void generate(Field field) {
        String name = field.getName();
        String descriptor = field.getType().getDescriptor();
        FieldVisitor fieldVisitor = classWriter.visitField(Opcodes.ACC_PUBLIC, name,descriptor, null, null);
        fieldVisitor.visitEnd();
    }
}
```

### 读取字段

为了获取一个字段你需要：

- 字段名
- 字段类型修饰符（如果字段是int类型，它意味着“I”）
- 所有者的内部名称（如果字段被com.yourcompany.Car所有，它就是“com/yourcompany/Car”）

```java
public class ReferenceExpressionGenerator {

     //constructor and fields

    public void generate(FieldReference fieldReference) {
        String varName = fieldReference.geName();
        Type type = fieldReference.getType();
        String ownerInternalName = fieldReference.getOwnerInternalName();
        String descriptor = type.getDescriptor();
        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);
        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, ownerInternalName,varName,descriptor);
    }
}
```

- `ALOAD,0` - 在索引为0的位置获取是局部变量的“this”对象。非静态的方法默认在局部变量表中的索引0的位置包含“this”的引用。
- `GETFIELD` - 读取字段的操作码

### 分配给字段

```java
public class AssignmentStatementGenerator {

    //constructor and fields
    
    public void generate(Assignment assignment) {
        String varName = assignment.getVarName();
        Expression expression = assignment.getExpression();
        Type type = expression.getType();
        if(scope.isLocalVariableExists(varName)) {
            int index = scope.getLocalVariableIndex(varName);
            methodVisitor.visitVarInsn(type.getStoreVariableOpcode(), index);
            return;
        }
        Field field = scope.getField(varName);
        String descriptor = field.getType().getDescriptor();
        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);
        expression.accept(expressionGenerator);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD,field.getOwnerInternalName(),field.getName(),descriptor);
    }
}
```

如果存在歧义，则局部变量的优先级高于字段。如果你声明的一个本地变量的名称与字段完全一致，则你不想引用字段而是引用一个本地变量，对吗？这就是为什么首先搜索局部变量的原因。

`PUTFIELD`操作码和`GETFIELD`类似，但是它将额外的项从栈中弹出 - 将要分配给字段的表达式的结果。

## 示例

下面的Enkel类：

```groovy
Fields {
    int field

    start {
        field = 5
        print field
    }
}
```

生成字节码：

```s
kuba@kuba-laptop:~/repos/Enkel-JVM-language$ javap -c Fields
public class Fields {
  public int field;

  public void start();
    Code:           
       0: aload_0               //get "this"
       1: ldc           #9      // load constant "5" from constant pool 
       3: putfield      #11     // Field field:I - pop 5 off the stack and write to field
       6: getstatic     #17     // Field java/lang/System.out:Ljava/io/PrintStream; 
       9: aload_0               //get "this" reference
      10: getfield      #11     // Field field:I
      13: invokevirtual #22     // Method "Ljava/io/PrintStream;".println:(I)V
      16: return

 //autogenerated constructor and main method
}
```

</br></br></br>

<div align="left"><a href="./16-引用其他的类(包括Java Api).md">上一节</a></div> 

<div align="left"><a href="./17-字段.md">下一节</a></div>